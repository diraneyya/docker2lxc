#!/usr/bin/env bash

prototype_path=${1:-.}
export prototype_binary=${prototype_path%/}/prototype
export unit_test_list=${prototype_path%/}/unit_tests.sh
export dummy_file_path=${prototype_path%/}/dummy

if ! [ -f "$prototype_binary" ]; then
    printf >&2 "\e[31;1m%s '%s', aborting...\e[0m\n" \
        "Could not find prototype binary at" "$prototype_binary"
    exit 1
fi

while IFS= read -r line
do
    if [[ "$line" =~ ^'# ' ]]; then
        expected_outcome=${line#'# '}
        continue
    fi

    # do not mistake empty lines for commands being tested
    if [[ -z "${line//[[:space:]]/}" ]]; then continue; fi

    parsed_line="$(echo -n "$line" | envsubst)"
    # unable to find a way to run the command and capture its content without
    # changing its behavior (in this case), I am now spinning up a new container
    # for each one of the commands I want to test, which is much less efficient
    # than before. An advantage of this design however is that only the prototype
    # binary needs to be copied into the container. However, there is still a
    # need to install bash inside the container unfortunately.
    eval "${parsed_line}" | tr "\t\v\r\n" "    " | sed 's/  */ /g'
    echo "line: ${parsed_line@Q}"
    echo "- outcome: $outcome"
    echo "- expected: $expected_outcome"
done < "$unit_test_list"